#' Read in GDX and calculate emissions, used in convGDX2MIF.R for the reporting
#' 
#' Read in emissions data from GDX file, information used in convGDX2MIF.R
#' for the reporting
#' 
#' 
#' @param gdx a GDX object as created by readGDX, or the path to a gdx
#' @param output a magpie object containing all needed variables generated by other report*.R functions
#' @return MAgPIE object - contains the emission variables
#' @author Sebastian Osorio, Renato Rodrigues
#' @seealso \code{\link{convGDX2MIF}}
#' @examples
#' 
#' \dontrun{reportEmissions(gdx)}
#'
#' @importFrom gdx readGDX
#' @importFrom magclass mbind setNames dimSums getSets getSets<- as.magpie
#' @export
#' 
reportEUETSvars <- function(gdx,output=NULL) {
  
  if(is.null(output)){
    stop("please provide a file containing all needed information")
  }
  
  # read parameters
  s_c2co2 <- readGDX(gdx,name="s_c2co2",field="l",format="first_found") #conversion factor C -> CO2
  c_bankemi_EU <- readGDX(gdx,name="c_bankemi_EU",field="l",format="first_found")
  
  #read variables
  v_bankemi <- readGDX(gdx,name="v_bankemi",field="l",format="first_found")
  p_emicappath_EUETS <- readGDX(gdx,name="p_emicappath_EUETS",field="l",format="first_found")
  
  #If variables should not exist (equations are off), write NA
  if(c_bankemi_EU == 0) {
    v_bankemi[] <- NA
    p_emicappath_EUETS[] <- NA
  } 
  
  #Initialize this variable
  o_aviation_demandEUA <- 0

  #report the variables 
  # !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  #(DO NOT FORGET TO INCLUDE THESE VARIABLES IN mappingvars and aggvars EXCEL FILES, and to include in the fictitious file)
  tmp1 <- NULL
  
  tmp2 <- NULL
  #Check the version so one can check if the industry is already included
  c_LIMESversion <- readGDX(gdx,name="c_LIMESversion",field="l",format="first_found")
  #until version 2.26 LIMES only included electricity
  if(c_LIMESversion <= 2.26) {
    tmp2 <- mbind(tmp2,setNames(v_bankemi[,,]*s_c2co2*1000,"Emissions level in ETS|CO2|Energy|Supply|Electricity (Mt CO2)"))
    tmp2 <- mbind(tmp2,setNames(p_emicappath_EUETS[,,]*s_c2co2*1000,"EU ETS cap|CO2|Energy|Supply|Electricity (Mt CO2/yr)"))
  } else {
    
    #check if industry is included in the run
    c_industry_ETS <- readGDX(gdx,name="c_industry_ETS",field="l",format="first_found")
    #distinguish the cap (for the whole EU ETS (stationary), electricity and industry or only electricity)
    if(c_industry_ETS == 0) {
      tmp2 <- mbind(tmp2,setNames(v_bankemi[,,]*s_c2co2*1000,"Emissions level in ETS|CO2|Energy|Supply|Electricity (Mt CO2)"))
      tmp2 <- mbind(tmp2,setNames(p_emicappath_EUETS[,,]*s_c2co2*1000,"EU ETS cap|CO2|Energy|Supply|Electricity (Mt CO2/yr)"))
    } else {
      tmp2 <- mbind(tmp2,setNames(v_bankemi[,,]*s_c2co2*1000,"Emissions level in ETS|CO2 (Mt CO2)"))
      
      #include the aviation variables (only available from 2.28)
      if (c_LIMESversion >= 2.28) {
        c_aviation <- readGDX(gdx,name="c_aviation",field="l",format="first_found")
        if(c_aviation == 1){
          p_aviation_cap <- readGDX(gdx,name="p_aviation_cap",field="l",format="first_found")
          p_aviation_emi <- readGDX(gdx,name="p_aviation_emi",field="l",format="first_found")
          o_aviation_demandEUA <- as.magpie(apply(mbind(p_aviation_emi*0,p_aviation_emi-p_aviation_cap),1:2,max))
          if (c_LIMESversion >= 2.31) {
            o_aviation_demandEUA <- readGDX(gdx,name="p_demaviationEUA",field="l",format="first_found")
          }
          #include historical emissions in 2015
          o_aviation_demandEUA[,2015,] <- 20/(s_c2co2*1000)
          
          tmp2 <- mbind(tmp2,setNames(p_aviation_cap[,,]*s_c2co2*1000,"Emissions|CO2|Cap|Aviation (Mt CO2/yr)"))
          tmp2 <- mbind(tmp2,setNames(p_aviation_emi[,,]*s_c2co2*1000,"Emissions|CO2|Aviation (Mt CO2/yr)"))
          tmp2 <- mbind(tmp2,setNames(o_aviation_demandEUA*s_c2co2*1000,"Emissions|CO2|Certificates from Stationary|Aviation (Mt CO2/yr)"))
        }
      }
      
      #LOADING LIST OF REGIONS TO AGGREGATE CERTAIN GROUPS (e.g., EU)
      # settings mapping path
      mappingregiPath <- system.file("extdata","LIMES_country_ISO_3.csv",package="limes")
      # reading mapping file
      mappingregi <- read.csv(mappingregiPath,sep=";")
      #loading the countries belonging to 'regeuets'
      regeuets_iso2 <- readGDX(gdx,name="regeuets")
      regeuets_iso3 <- mappingregi[match(regeuets_iso2,mappingregi[,1]),2]
      regeuets <- regeuets_iso3 #Better to take it directly from the GDX file
      o_emi_elec_ind <- NULL
      if(length(which(getNames(output) == "Emissions|CO2|Electricity and Industry (Mt CO2/yr)")) > 0) {
        o_emi_elec_ind <- dimSums(output[regeuets,,"Emissions|CO2|Electricity and Industry (Mt CO2/yr)"], dim=1)
      }
      
      #Load share from heating
      p_shareheating_EUETS <- readGDX(gdx,name="p_shareheating_EUETS",field="l",format="first_found")
      #In v2.27 there is no heating. Thus, if industry was included, the share for heating had to be subtracted
      if(c_LIMESversion == 2.27) {
        tmp2 <- mbind(tmp2,setNames(p_emicappath_EUETS[,,]*s_c2co2*1000,"Emissions|CO2|Cap|Stationary|Electricity and Industry (Mt CO2/yr)"))
        tmp2 <- mbind(tmp2,setNames(p_emicappath_EUETS[,,]*s_c2co2*1000/(1-p_shareheating_EUETS),"Emissions|CO2|Cap|Stationary (Mt CO2/yr)"))
      } else {
        #Load switch for heating
        c_heating <- readGDX(gdx,name="c_heating",field="l",format="first_found")
        p_certificates_cancelled <- readGDX(gdx,name="p_certificates_cancelled",field="l",format="first_found")
        if(c_heating == 0) {
          
          #From this version, we estimate differently the auction, free allocation, unilateral cancellation, and thus the cap
          if(c_LIMESversion <= 2.30) {
            tmp2 <- mbind(tmp2,setNames(p_emicappath_EUETS[,,]*s_c2co2*1000,"Emissions|CO2|Cap|Stationary|Electricity and Industry (Mt CO2/yr)"))
            o_prelcap <- ((p_emicappath_EUETS[,,]+o_aviation_demandEUA)*s_c2co2*1000+p_certificates_cancelled)/(1-p_shareheating_EUETS)
            tmp2 <- mbind(tmp2,setNames(o_prelcap,"Emissions|CO2|Cap|Stationary (Mt CO2/yr)"))
            o_exoemiheat <- o_prelcap*p_shareheating_EUETS
            o_exoemiheat[,c(2010,2015),] <- c(317,272)  #include historical heating emisions from 2010 and 2015
            tmp2 <- mbind(tmp2,setNames(o_exoemiheat,"Emissions|CO2|Energy|Supply|Heat (Mt CO2/yr)"))
            if(!is.null(o_emi_elec_ind)) {
              tmp2 <- mbind(tmp2,setNames(o_emi_elec_ind + o_exoemiheat,"Emissions|CO2|EU ETS (Mt CO2/yr)")) #this does not include aviation demand
              tmp2 <- mbind(tmp2,setNames(o_emi_elec_ind + o_exoemiheat + o_aviation_demandEUA*s_c2co2*1000,"Emissions|CO2|EU ETS|w/ aviation (Mt CO2/yr)")) #this includes aviation demand
            }
            
          } else {#c_heating == 0 and c_LIMESversion > 2.30
            p_exoemiheat <- readGDX(gdx,name="p_exoemiheat",field="l",format="first_found") #exogenous emissions from heating (share of cap)
            p_exoemiheat[,c(2010,2015),] <- c(317,272)/as.vector(s_c2co2*1000)  #include historical heating emisions from 2010 and 2015
            p_emiothersec <- readGDX(gdx,name="p_emiothersec",field="l",format="first_found") #exogenous emissions (from other sectors if introduced into the EU ETS)
            tmp2 <- mbind(tmp2,setNames(p_emiothersec*s_c2co2*1000,"Emissions|CO2|Additional sectors in EU ETS (Mt CO2/yr)"))
            if(!is.null(o_emi_elec_ind)) {
              tmp2 <- mbind(tmp2,setNames(o_emi_elec_ind + (p_exoemiheat + p_emiothersec)*s_c2co2*1000,"Emissions|CO2|EU ETS (Mt CO2/yr)")) #this does not include aviation demand
              tmp2 <- mbind(tmp2,setNames(o_emi_elec_ind + (p_exoemiheat + p_emiothersec + o_aviation_demandEUA)*s_c2co2*1000,"Emissions|CO2|EU ETS|w/ aviation (Mt CO2/yr)")) #this includes aviation demand
            }
            #Previous version did not have endogenous heating 
            #-> with endogenous this variable will be calculated from the region-based heating
            tmp2 <- mbind(tmp2,setNames(p_exoemiheat*s_c2co2*1000,"Emissions|CO2|Energy|Supply|Heat (Mt CO2/yr)"))
            
            if(c_LIMESversion <= 2.33) {
              tmp2 <- mbind(tmp2,setNames(p_emicappath_EUETS[,,]*s_c2co2*1000,"Emissions|CO2|Cap|Stationary (Mt CO2/yr)"))
            } else {
              p_emicap_EUETS <- readGDX(gdx,name="p_emicap_EUETS",field="l",format="first_found")
              tmp2 <- mbind(tmp2,setNames(p_emicap_EUETS[,,]*s_c2co2*1000,"Emissions|CO2|Cap|Stationary (Mt CO2/yr)"))
              p_unsoldEUA <- readGDX(gdx,name="p_unsoldEUA",field="l",format="first_found")
              tmp2 <- mbind(tmp2,setNames(p_emicap_EUETS[,,]*s_c2co2*1000,"Emissions|CO2|Unallocated certificates (Mt CO2/yr)"))
            }
            
          }
          
        } else {#c_heating == 1
          if(c_LIMESversion <= 2.33) {
            tmp2 <- mbind(tmp2,setNames(p_emicappath_EUETS[,,]*s_c2co2*1000,"Emissions|CO2|Cap|Stationary (Mt CO2/yr)"))
          } else {
            p_emicap_EUETS <- readGDX(gdx,name="p_emicap_EUETS",field="l",format="first_found")
            tmp2 <- mbind(tmp2,setNames(p_emicap_EUETS[,,]*s_c2co2*1000,"Emissions|CO2|Cap|Stationary (Mt CO2/yr)"))
            p_unsoldEUA <- readGDX(gdx,name="p_unsoldEUA",field="l",format="first_found")
            tmp2 <- mbind(tmp2,setNames(p_unsoldEUA[,,]*s_c2co2*1000,"Emissions|CO2|Unallocated certificates (Mt CO2/yr)"))
          }
          
          p_emiothersec <- readGDX(gdx,name="p_emiothersec",field="l",format="first_found") #exogenous emissions (from other sectors if introduced into the EU ETS)
          tmp2 <- mbind(tmp2,setNames(p_emiothersec*s_c2co2*1000,"Emissions|CO2|Additional sectors in EU ETS (Mt CO2/yr)"))
          
          #EU ETS emissions when there is endogenous heating
          o_emi_heat <- NULL
          if(length(which(getNames(output) == "Emissions|CO2|Energy|Supply|Heat (Mt CO2/yr)")) > 0) {
            o_emi_heat <- dimSums(output[regeuets,,"Emissions|CO2|Energy|Supply|Heat (Mt CO2/yr)"], dim=1)
          }
          if(!is.null(o_emi_elec_ind) & !is.null(o_emi_heat)) {
            tmp2 <- mbind(tmp2,setNames(o_emi_elec_ind + o_emi_heat + p_emiothersec*s_c2co2*1000,"Emissions|CO2|EU ETS (Mt CO2/yr)")) #this does not include stationary certificates for aviation
            tmp2 <- mbind(tmp2,setNames(o_emi_elec_ind + o_emi_heat + (p_emiothersec + o_aviation_demandEUA)*s_c2co2*1000,"Emissions|CO2|EU ETS|w/ aviation (Mt CO2/yr)")) #this includes stationary certificates for aviation
          }
          
        }
      }
      
    }
    
  } 
  
  # concatenate data
  tmp <- mbind(tmp1,tmp2)

  return(tmp)
}
  
